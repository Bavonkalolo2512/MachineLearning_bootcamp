# -*- coding: utf-8 -*-
"""data science.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uyC7LxQ_lUr3Fz8nNJla_TovsYw18zQh

**Map Reduce Filter**

**MAP**

La fonction permet d'appliquer une fonction a chaque valeur d'une liste.
ceci permet de traiter une liste ou un tuple de maniere efficace sans passer par une boucle **FOR**

Par exemple on veut obtenir la racine carree de chaque valeur d'une liste appele **COTE** , grace a la fonction CARRE
"""

COTE = [5,6,7,8,9]

def CARRE (x):
  return x**2

resultat = list(map(CARRE,COTE))

print(resultat)

"""**bold text**

**LA FONCTION LAMBDA**

la fonction lambda est une nouvelle maniere de declarer une fonction mais cette fois ci sans nom, elle est aussi appele fonction anonyme.
on peut appliquer LAMBDA sur le MAP et le FILTER
son plus grand avantage est qu''il reduit la complicite en temps d'un algorithme.
**Exemple**
"""

from re import X
# on commence d''abord par declarer la liste sur laquelle sera applique la fonction lambda
Math =  [5,4,6,1,7,8,9,2]
print(list(map(lambda x: x*2,Math)))

"""**FILTER**
le filter permet de renvoyer une partie d'une sequence suivant un critere bien precis exprimee grace a une fonction passe en parametre de la fonction filter
**Exemple :**
"""

# reprenons l'exemple de notre liste precedente :
Math =  [5,2,3,4,6,1,7,8,9,2]
#on veut renvoyer une sequence contenant les cotes superieur a 5

print(list(filter(lambda x: x < 5, Math)))

"""**object oriented programing  OOP** // La Programmation Orientee Objet
ici nous allons nous interresser aux notions de CLASS, D'OBJET,POLYMORPHISME, D'ENCAPSULATION et d'INHERITANCE

"""

# Definissons un objet Personne
class Personne:
  def __init__(self,nom,age):  # ceci est un constructeur
    self.nom = nom
    self.age = age
    #ajoutons une methode
  def sePresenter(self):
     print(f"je m'appel {self.nom} et j\'ai {self.age} ans")


# creons une instance de la classe personne Personne1 et personne2
personne1 = Personne("Malick", 20)
personne2 = Personne("Moussa", 35)

# Affichons les informations des personnes creee
print(f"Nom : {personne1.nom}\nAge : {personne1.age} ans")
print(f"Nom : {personne2.nom}\nAge : {personne2.age} ans")

#appelons la methode sePresenter des l'objets Personnes
personne1.sePresenter()
personne2.sePresenter()

"""**L'HERITAGE** est le fait que une classe peut heriter des methodes d'une classe appeler une classe mere"""

#creons la classe personne

class Person :
  def __init__(self, firstname, lastname):
    self.firstname = firstname
    self.lastname = lastname

  def identity (self):
    print(f"Bonjour je m\'appel {self.firstname} et {self.lastname}")

# maintenant creons la classe STUDENT qui herite de la classe Person ci-haut
class Student(Person):
  def __init__(self, firstname, lastname, degree):
    super().__init__(firstname,lastname)
    self.degree = degree

# Extencons la classe STUDENT et appelons la methode identity sur la classe
# Student pour voir si l'heritage est effectif

Student1 = Student("Malick", "Jean", "Master")
Student1.identity()

"""**Le POLYMORPHISME** : Poly: pour plusieurs et morphpour forme, le polymophisme est une notion de la POO permettant a la methode de la classe mere de prendre plusieurs formes selon les sous classes


"""

# Utilisons la classe Personne pour démontrer le polymorphisme
class Teacher(Person):
    def __init__(self, firstname, lastname, subject):
        super().__init__(firstname, lastname)
        self.subject = subject

    # Remplacer la méthode identity pour montrer le polymorphisme
    def identity(self):
        print(f"Bonjour, je m'appelle {self.firstname} {self.lastname} et j'enseigne {self.subject}")

# Creons des instances de Personne et Enseignant pour voir la diffence entre le Deux
person = Person("Alice", "Smith")
teacher = Teacher("Bob", "Johnson", "Math")

# appelons la méthode identity sur les deux objets
person.identity()
teacher.identity()

"""L'ENCAPSULATION : Permet de restreindre l'acces direct exterieur aux methodes et aux variable, et aussi de cacher les details l'implementation"""



# Définissons une classe avec encapsulation
class CompteBancaire:
    def __init__(self, solde_initial):
        # L'attribut __solde est privé grâce au double underscore
        self.__solde = solde_initial

    # Méthode pour obtenir le solde grace au getter (accesseur)
    def get_solde(self):
        # Permet d'accéder à l'attribut privé
        return self.__solde

    # Méthode pour déposer de l'argent
    def deposer(self, montant):
        if montant > 0:
            self.__solde += montant
            print(f"Dépôt de {montant} effectué. Nouveau solde : {self.__solde}")
        else:
            print("Le montant du dépôt doit être positif.")

    # Méthode pour retirer de l'argent
    def retirer(self, montant):
        # Vérifie si le solde est suffisant et le montant est positif
        if 0 < montant <= self.__solde:
            self.__solde -= montant # le setteur
            print(f"Retrait de {montant} effectué. Nouveau solde : {self.__solde}")
        else:
            print("Solde insuffisant ou montant invalide.")

# Créons une instance de la classe CompteBancaire
mon_compte = CompteBancaire(1000)

# Tentons d'accéder directement à l'attribut privé (normalment ceci va generer une erreur
# print(mon_compte.__solde)

# Utilisons la méthode getter pour accéder au solde
print(f"Solde actuel via getter : {mon_compte.get_solde()}")

# Effectuons des opérations via les méthodes publiques (encapsulation)
mon_compte.deposer(500)
mon_compte.retirer(200)

# Affichons le solde final via le getter
print(f"Solde final via getter : {mon_compte.get_solde()}")

"""DEBUTER AVEC NUMPY : Numerical Python est utilise pour sa rapidite dans la manipulation de tableau multidimentionel et consomme de d'espace memoire.

il est base principalement sur le tableau ARRAY()
"""

# On commence par toujour importer la librerie car elle externe a python et elle est ecrit en langage C
import numpy as np

# creons un tableau a partir de d'une liste
table = np.array([1,2,3,4,5])
print(table)

# verifions le type de notre variable Table
print(type(table))

# definissons un tableau a 2 dimensions
table2 = np.array([[1,2,4,5], [3,4,5,6]])
print(table2)

# combien de dimention a table2
table2.ndim

# NB: un tableau a une dimention est appele vecteur, et celui de 2 dimension Matrice

# passons maintenant au tableau a 3 dimention
table3 = np.array([
    [
        ['a','b','c'],
        ['d','e','f']
        ],
  [
      ['g','h','i'],
      ['j','k','k']
      ],
  [
      ['l','m','n'],
      ['o','p','q']
      ],
  [
      ['r','s','u'],
      ['v','w','x']
      ]
    ])
print(table3)

# nombre de dimension
table3.ndim

# maintenant accedons aux differnte valeur
# comme exercice nous allons acceder aux valeurs en pour ecrire le mot LIKE

# creation d'un table de zeros contenant 3 lignes et 3 colonnes, puis un autre contenant 3 ligne et 6 colonnes
tableau1 = np.zeros((3,3))
print("tableau 1 \n")
print(tableau1)
print("tableau 2 \n")
tableau2 = np.zeros((6,3))
print(tableau2)

#creation d'un tableau de 1 de 10 ligne et 3 connes
tableau3 = np.ones((10,3))
print(tableau3)

# la creation d'un tableau ayant 5 ligne et 5 colonne avec 1 en diagonal
tableau4 = np.eye(5)
print(tableau4)

# creation d'un tableau de donné automatique grace a la fonction ARANGE
tableau5 = np.arange(10)
print(tableau5)

# avec 2 parametre : debut et fin
tableau6 = np.arange(1,15)

# avec 3 parametre : debut,fin et pas d'incrementation
tableau6 = np.arange(1,17, 2)
print(tableau6)

# creation d'un tableau avec les valeurs aleatoire
tableau7 = np.random.randint(0,10,20)
print(tableau7)

# gener une sequence de nombre compris entre 2 nombre avec un ecart regulier

tableau8 = np.linspace(1,10,15)
print(tableau8)

# Acceder aux element, selectionner, modifier et mettre a jour nunpy
array = np.arange(10)
print(array)

# selectionner le premier elemnent du tableau
print(array[0])

# modifier la troisieme valeur du tableau
array[2] = 15
print(array)

# selectionner les valeurs superieur ou egale a 5
valeurs = array[array > 5]
print(valeurs)

# au lieu de renvoyer les valeurs, renvoyer plutot leurs indices
indices = np.where(array > 5)
print(indices)

# remplacer toutes les valeurs inferieur  a 5 par la valeur zero
array[array < 5] = 0
print(array)

# les operation sur les tableau
tab1 = np.arange(5)
tab2 = np.random.randint(1,10,5)